<?xml version="1.0" encoding="UTF-8" ?>
<section acro="O">
<title>Orthogonality</title>

<!-- %%%%%%%%%% -->
<!-- % -->
<!-- %  Section O -->
<!-- %  Orthogonality -->
<!-- % -->
<!-- %%%%%%%%%% -->
<introduction>
<p>In this section we define a couple more operations with vectors, and prove a few theorems.  At first blush these definitions and results will not appear central to what follows, but we will make use of them at key points in the remainder of the course (such as <acroref type="section" acro="MINM" />, <acroref type="section" acro="OD" />).  Because we have chosen to use $\complexes$ as our set of scalars, this subsection is a bit more, uh, <ellipsis /> complex than it would be for the real numbers.  We will explain as we go along how things get easier for the real numbers ${\mathbb R}$.  If you have not already, now would be a good time to review some of the basic properties of arithmetic with complex numbers described in <acroref type="section" acro="CNO" />.  With that done, we can extend the basics of complex number arithmetic to our study of vectors in $\complex{m}$.</p>

</introduction>

<subsection acro="CAV">
<title>Complex Arithmetic and Vectors</title>

<p>We know how the addition and multiplication of complex numbers is employed in defining the operations for vectors in $\complex{m}$ (<acroref type="definition" acro="CVA" /> and <acroref type="definition" acro="CVSM" />).  We can also extend the idea of the conjugate to vectors.</p>

<definition acro="CCCV" index="conjugate!column vector">
<title>Complex Conjugate of a Column Vector</title>
<p>Suppose that $\vect{u}$ is a vector from $\complex{m}$.  Then the conjugate of the vector, $\conjugate{\vect{u}}$, is defined by
<alignmath>
\vectorentry{\conjugate{\vect{u}}}{i}
<![CDATA[&=\conjugate{\vectorentry{\vect{u}}{i}}]]>
<![CDATA[&&\text{$1\leq i\leq m$}]]>
</alignmath>
</p>

<notation acro="CCCV" index="conjugate of a vector">
<title>Complex Conjugate of a Column Vector</title>
<usage>$\conjugate{\vect{u}}$</usage>
</notation>
</definition>

<p>With this definition we can show that the conjugate of a column vector behaves as we would expect with regard to vector addition and scalar multiplication.</p>

<theorem acro="CRVA" index="conjugate!vector addition">
<title>Conjugation Respects Vector Addition</title>
<statement>
<p>Suppose $\vect{x}$ and $\vect{y}$ are two vectors from $\complex{m}$.  Then
<equation>
\conjugate{\vect{x}+\vect{y}}=\conjugate{\vect{x}}+\conjugate{\vect{y}}
</equation>
</p>

</statement>

<proof>
<p>For each $1\leq i\leq m$,
<alignmath>
\vectorentry{\conjugate{\vect{x}+\vect{y}}}{i}
<![CDATA[&=\conjugate{\vectorentry{\vect{x}+\vect{y}}{i}}&&]]><acroref type="definition" acro="CCCV" />\\
<![CDATA[&=\conjugate{\vectorentry{\vect{x}}{i}+\vectorentry{\vect{y}}{i}}&&]]><acroref type="definition" acro="CVA" />\\
<![CDATA[&=\conjugate{\vectorentry{\vect{x}}{i}}+\conjugate{\vectorentry{\vect{y}}{i}}&&]]><acroref type="theorem" acro="CCRA" />\\
<![CDATA[&=\vectorentry{\conjugate{\vect{x}}}{i}+\vectorentry{\conjugate{\vect{y}}}{i}&&]]><acroref type="definition" acro="CCCV" />\\
<![CDATA[&=\vectorentry{\conjugate{\vect{x}}+\conjugate{\vect{y}}}{i}&&]]><acroref type="definition" acro="CVA" />
</alignmath>
</p>

<p>Then by <acroref type="definition" acro="CVE" /> we have $\conjugate{\vect{x}+\vect{y}}=\conjugate{\vect{x}}+\conjugate{\vect{y}}$.</p>

</proof>
</theorem>

<theorem acro="CRSM" index="conjugate!scalar multiplication">
<title>Conjugation Respects Vector Scalar Multiplication</title>
<statement>
<p>Suppose $\vect{x}$ is a vector from $\complex{m}$, and $\alpha\in\complexes$ is a scalar.  Then
<equation>
\conjugate{\alpha\vect{x}}=\conjugate{\alpha}\,\conjugate{\vect{x}}
</equation>
</p>

</statement>

<proof>
<p>For $1\leq i\leq m$,
<alignmath>
\vectorentry{\conjugate{\alpha\vect{x}}}{i}
<![CDATA[&=\conjugate{\vectorentry{\alpha\vect{x}}{i}}&&]]><acroref type="definition" acro="CCCV" />\\
<![CDATA[&=\conjugate{\alpha\vectorentry{\vect{x}}{i}}&&]]><acroref type="definition" acro="CVSM" />\\
<![CDATA[&=\conjugate{\alpha}\,\conjugate{\vectorentry{\vect{x}}{i}}&&]]><acroref type="theorem" acro="CCRM" />\\
<![CDATA[&=\conjugate{\alpha}\,\vectorentry{\conjugate{\vect{x}}}{i}&&]]><acroref type="definition" acro="CCCV" />\\
<![CDATA[&=\vectorentry{\conjugate{\alpha}\,\conjugate{\vect{x}}}{i}&&]]><acroref type="definition" acro="CVSM" />\\
</alignmath>
</p>

<p>Then by <acroref type="definition" acro="CVE" /> we have $\conjugate{\alpha\vect{x}}=\conjugate{\alpha}\,\conjugate{\vect{x}}$.</p>

</proof>
</theorem>

<p>These two theorems together tell us how we can <q>push</q> complex conjugation through linear combinations.
</p>

</subsection>

<subsection acro="IP">
<title>Inner products</title>

<definition acro="IP" index="vector!inner product">
<title>Inner Product</title>
<p>Given the vectors $\vect{u},\,\vect{v}\in\complex{m}$ the <define>inner product</define> of $\vect{u}$ and $\vect{v}$ is the scalar quantity in $\complex{\null}$,
<equation>
\innerproduct{\vect{u}}{\vect{v}}=
\conjugate{\vectorentry{\vect{u}}{1}}\vectorentry{\vect{v}}{1}+
\conjugate{\vectorentry{\vect{u}}{2}}\vectorentry{\vect{v}}{2}+
\conjugate{\vectorentry{\vect{u}}{3}}\vectorentry{\vect{v}}{3}+
\cdots+
\conjugate{\vectorentry{\vect{u}}{m}}\vectorentry{\vect{v}}{m}
=
\sum_{i=1}^{m}\conjugate{\vectorentry{\vect{u}}{i}}\vectorentry{\vect{v}}{i}
</equation>
</p>

<notation acro="IP" index="inner product">
<title>Inner Product</title>
<usage>$\innerproduct{\vect{u}}{\vect{v}}$</usage>
</notation>
</definition>

<p>This operation is a bit different in that we begin with two vectors but produce a scalar.  Computing one is straightforward.
</p>

<example acro="CSIP" index="inner product">
<title>Computing some inner products</title>

<p>The inner product of
<alignmath>
<![CDATA[\vect{u}=\colvector{2+3i\\5+2i\\-3+i}&&\text{and}&&]]>
\vect{v}=\colvector{1+2i\\-4+5i\\0+5i}
</alignmath>
is
<alignmath>
\innerproduct{\vect{u}}{\vect{v}}
<![CDATA[&=(\conjugate{2+3i})(1+2i)+(\conjugate{5+2i})(-4+5i)+(\conjugate{-3+i})(0+5i)\\]]>
<![CDATA[&=(2-3i)(1+2i)+(5-2i)(-4+5i)+(-3-i)(0+5i)\\]]>
<![CDATA[&=(8+i)+(-10+33i)+(5-15i)\\]]>
<![CDATA[&=3+19i]]>
</alignmath>
</p>

<p>The inner product of
<alignmath>
<![CDATA[\vect{w}=\colvector{2\\4\\-3\\2\\8}&&\text{and}&&]]>
\vect{x}=\colvector{3\\1\\0\\-1\\-2}
</alignmath>
is
<alignmath>
<![CDATA[\innerproduct{\vect{w}}{\vect{x}}&=]]>
(\conjugate{2})3+(\conjugate{4})1+(\conjugate{-3})0+(\conjugate{2})(-1)+(\conjugate{8})(-2)\\
<![CDATA[&=2(3)+4(1)+(-3)0+2(-1)+8(-2)=-8.]]>
</alignmath>
</p>

</example>

<p>In the case where the entries of our vectors are all real numbers (as in the second part of <acroref type="example" acro="CSIP" />), the computation of the inner product may look familiar and be known to you as a <define>dot product</define> or <define>scalar product</define>.  So you can view the inner product as a generalization of the scalar product to vectors from $\complex{m}$ (rather than ${\mathbb R}^m$).</p>

<p>Note that we have chosen to conjugate the entries of the <em>first</em> vector listed in the inner product, while it is almost equally feasible to conjugate entries from the <em>second</em> vector instead.  In particular, prior to Version 2.90, we did use the latter definition, and this has now changed to the former, with resulting adjustments propogated up through <acroref type="section" acro="CB" /> (only).  However, conjugating the first vector leads to much nicer formulas for certain matrix decompositions and also shortens some proofs.</p>

<p>There are several quick theorems we can now prove, and they will each be useful later.</p>

<theorem acro="IPVA" index="inner product!vector addition">
<title>Inner Product and Vector Addition</title>
<statement>
<p>Suppose $\vect{u},\,\vect{v},\,\vect{w}\in\complex{m}$.  Then
<ol>
<li>$\innerproduct{\vect{u}+\vect{v}}{\vect{w}}=\innerproduct{\vect{u}}{\vect{w}}+\innerproduct{\vect{v}}{\vect{w}}$</li>
<li>$\innerproduct{\vect{u}}{\vect{v}+\vect{w}}=\innerproduct{\vect{u}}{\vect{v}}+\innerproduct{\vect{u}}{\vect{w}}$</li>
</ol>
</p>

</statement>

<proof>
<p>The proofs of the two parts are very similar, with the second one requiring just a bit more effort due to the conjugation that occurs.  We will prove part 1 and you can prove part 2 (<acroref type="exercise" acro="O.T10" />).
<alignmath>
\innerproduct{\vect{u}+\vect{v}}{\vect{w}}
<![CDATA[&=\sum_{i=1}^{m}\conjugate{\vectorentry{\vect{u}+\vect{v}}{i}}\vectorentry{\vect{w}}{i}]]>
<![CDATA[&&]]><acroref type="definition" acro="IP" />\\
<![CDATA[&=\sum_{i=1}^{m}\left(\conjugate{\vectorentry{\vect{u}}{i}+]]>
\vectorentry{\vect{v}}{i}}\right)\vectorentry{\vect{w}}{i}
<![CDATA[&&]]><acroref type="definition" acro="CVA" />\\
<![CDATA[&=\sum_{i=1}^{m}\left(\conjugate{\vectorentry{\vect{u}}{i}}+]]>
\conjugate{\vectorentry{\vect{v}}{i}}\right)\vectorentry{\vect{w}}{i}
<![CDATA[&&]]><acroref type="theorem" acro="CCRA" />\\
<![CDATA[&=\sum_{i=1}^{m}\conjugate{\vectorentry{\vect{u}}{i}}\vectorentry{\vect{w}}{i}]]>
              + \conjugate{\vectorentry{\vect{v}}{i}}\vectorentry{\vect{w}}{i}
<![CDATA[&&]]><acroref type="property" acro="DCN" />\\
<![CDATA[&=\sum_{i=1}^{m}\conjugate{\vectorentry{\vect{u}}{i}}\vectorentry{\vect{w}}{i}]]>
 +\sum_{i=1}^{m}\conjugate{\vectorentry{\vect{v}}{i}}\vectorentry{\vect{w}}{i}
<![CDATA[&&]]><acroref type="property" acro="CACN" />\\
<![CDATA[&=\innerproduct{\vect{u}}{\vect{w}}+\innerproduct{\vect{v}}{\vect{w}}&&]]><acroref type="definition" acro="IP" />
</alignmath>
</p>

</proof>
</theorem>

<theorem acro="IPSM" index="inner product!scalar multiplication">
<title>Inner Product and Scalar Multiplication</title>
<statement>
<p>Suppose $\vect{u},\,\vect{v}\in\complex{m}$ and $\alpha\in\complex{\null}$.  Then
<ol>
<li>$\innerproduct{\alpha\vect{u}}{\vect{v}}=\conjugate{\alpha}\innerproduct{\vect{u}}{\vect{v}}$</li>
<li>$\innerproduct{\vect{u}}{\alpha\vect{v}}=\alpha\innerproduct{\vect{u}}{\vect{v}}$</li>
</ol>
</p>

</statement>

<proof>
<p>The proofs of the two parts are very similar, with the second one requiring just a bit more effort due to the conjugation that occurs.  We will prove part 1 and you can prove part 2  (<acroref type="exercise" acro="O.T11" />).
<alignmath>
\innerproduct{\alpha\vect{u}}{\vect{v}}
<![CDATA[&=\sum_{i=1}^{m}\conjugate{\vectorentry{\alpha\vect{u}}{i}}\vectorentry{\vect{v}}{i}]]>
<![CDATA[&&]]><acroref type="definition" acro="IP" />\\
<![CDATA[&=\sum_{i=1}^{m}\conjugate{\alpha\vectorentry{\vect{u}}{i}}\vectorentry{\vect{v}}{i}]]>
<![CDATA[&&]]><acroref type="definition" acro="CVSM" />\\
<![CDATA[&=\sum_{i=1}^{m}\conjugate{\alpha}\,\conjugate{\vectorentry{\vect{u}}{i}}\vectorentry{\vect{v}}{i}]]>
<![CDATA[&&]]><acroref type="theorem" acro="CCRM" />\\
<![CDATA[&=\conjugate{\alpha}\sum_{i=1}^{m}\conjugate{\vectorentry{\vect{u}}{i}}\vectorentry{\vect{v}}{i}]]>
<![CDATA[&&]]><acroref type="property" acro="DCN" />\\
<![CDATA[&=\conjugate{\alpha}\innerproduct{\vect{u}}{\vect{v}}]]>
<![CDATA[&&]]><acroref type="definition" acro="IP" />
</alignmath>
</p>

</proof>
</theorem>

<theorem acro="IPAC" index="inner product!anti-commutative">
<title>Inner Product is Anti-Commutative</title>
<statement>
<p>Suppose that $\vect{u}$ and $\vect{v}$ are vectors in $\complex{m}$.  Then
$\innerproduct{\vect{u}}{\vect{v}}=\conjugate{\innerproduct{\vect{v}}{\vect{u}}}$.</p>

</statement>

<proof>
<p>
<alignmath>
\innerproduct{\vect{u}}{\vect{v}}
<![CDATA[&=\sum_{i=1}^{m}\conjugate{\vectorentry{\vect{u}}{i}}\vectorentry{\vect{v}}{i}]]>
<![CDATA[&&]]><acroref type="definition" acro="IP" />\\
<![CDATA[&=\sum_{i=1}^{m}\conjugate{\vectorentry{\vect{u}}{i}}\,\conjugate{\conjugate{\vectorentry{\vect{v}}{i}}}]]>
<![CDATA[&&]]><acroref type="theorem" acro="CCT" />\\
<![CDATA[&=\sum_{i=1}^{m}\conjugate{\vectorentry{\vect{u}}{i}\conjugate{\vectorentry{\vect{v}}{i}}}]]>
<![CDATA[&&]]><acroref type="theorem" acro="CCRM" />\\
<![CDATA[&=\conjugate{\left(\sum_{i=1}^{m}\vectorentry{\vect{u}}{i}\conjugate{\vectorentry{\vect{v}}{i}}\right)}]]>
<![CDATA[&&]]><acroref type="theorem" acro="CCRA" />\\
<![CDATA[&=\conjugate{\left(\sum_{i=1}^{m}\conjugate{\vectorentry{\vect{v}}{i}}\vectorentry{\vect{u}}{i}\right)}]]>
<![CDATA[&&]]><acroref type="property" acro="CMCN" />\\
<![CDATA[&=\conjugate{\innerproduct{\vect{v}}{\vect{u}}}]]>
<![CDATA[&&]]><acroref type="definition" acro="IP" />\\
</alignmath>
</p>

</proof>
</theorem>

</subsection>

<subsection acro="N">
<title>Norm</title>

<p>If treating linear algebra in a more geometric fashion, the length of a vector occurs naturally, and is what you would expect from its name.   With complex numbers, we will define a similar function.  Recall that if $c$ is a complex number, then $\modulus{c}$ denotes its modulus (<acroref type="definition" acro="MCN" />).</p>

<definition acro="NV" index="vector!norm">
<title>Norm of a Vector</title>
<p>The <define>norm</define> of the vector $\vect{u}$ is the scalar quantity in $\complex{\null}$
<equation>
\norm{\vect{u}}=
\sqrt{
\modulus{\vectorentry{\vect{u}}{1}}^2+
\modulus{\vectorentry{\vect{u}}{2}}^2+
\modulus{\vectorentry{\vect{u}}{3}}^2+
\cdots+
\modulus{\vectorentry{\vect{u}}{m}}^2
}
=
\sqrt{\sum_{i=1}^{m}\modulus{\vectorentry{\vect{u}}{i}}^2}
</equation>
</p>

<notation acro="NV" index="norm">
<title>Norm of a Vector</title>
<usage>$\norm{\vect{v}}$</usage>
</notation>
</definition>

<p>Computing a norm is also easy to do.</p>

<example acro="CNSV" index="norm">
<title>Computing the norm of some vectors</title>

<p>The norm of
<equation>
\vect{u}=\colvector{3+2i\\1-6i\\2+4i\\2+i}
</equation>
is
<alignmath>
<![CDATA[\norm{\vect{u}}&=]]>
\sqrt{\modulus{3+2i}^2+\modulus{1-6i}^2+\modulus{2+4i}^2+\modulus{2+i}^2}\\
<![CDATA[&=\sqrt{13+37+20+5}=\sqrt{75}=5\sqrt{3}]]>
</alignmath>
</p>

<p>The norm of
<equation>
\vect{v}=\colvector{3\\-1\\2\\4\\-3}
</equation>
is
<equation>
\norm{\vect{v}}=
\sqrt{\modulus{3}^2+\modulus{-1}^2+\modulus{2}^2+\modulus{4}^2+\modulus{-3}^2}
=\sqrt{3^2+1^2+2^2+4^2+3^2}=\sqrt{39}.
</equation>
</p>

</example>

<p>Notice how the norm of a vector with real number entries is just the length of the vector.  Inner products and norms are related by the following theorem.</p>

<theorem acro="IPN" index="inner product!norm">
<title>Inner Products and Norms</title>
<statement>
<indexlocation index="norm!inner product" />
<p>Suppose that $\vect{u}$ is a vector in $\complex{m}$.  Then
$\norm{\vect{u}}^2=\innerproduct{\vect{u}}{\vect{u}}$.
</p>

</statement>

<proof>
<p>
<alignmath>
\norm{\vect{u}}^2
<![CDATA[&=\left(\sqrt{\sum_{i=1}^{m}\modulus{\vectorentry{\vect{u}}{i}}^2}\right)^2]]>
<![CDATA[&&]]><acroref type="definition" acro="NV" />\\
<![CDATA[&=\sum_{i=1}^{m}\modulus{\vectorentry{\vect{u}}{i}}^2]]>
<![CDATA[&&]]>\text{Inverse functions}\\
<![CDATA[&=\sum_{i=1}^{m}\conjugate{\vectorentry{\vect{u}}{i}}\vectorentry{\vect{u}}{i}]]>
<![CDATA[&&]]><acroref type="definition" acro="MCN" />\\
<![CDATA[&=\innerproduct{\vect{u}}{\vect{u}}]]>
<![CDATA[&&]]><acroref type="definition" acro="IP" />
</alignmath>
</p>

</proof>
</theorem>

<p>When our vectors have entries only from the real numbers <acroref type="theorem" acro="IPN" /> says that the dot product of a vector with itself is equal to the length of the vector squared.</p>

<theorem acro="PIP" index="inner product!positive">
<title>Positive Inner Products</title>
<statement>
<p>Suppose that $\vect{u}$ is a vector in $\complex{m}$.  Then
$\innerproduct{\vect{u}}{\vect{u}}\geq 0$ with equality if and only if $\vect{u}=\zerovector$.</p>

</statement>

<proof>
<p>From the proof of <acroref type="theorem" acro="IPN" />  we see that
<equation>
\innerproduct{\vect{u}}{\vect{u}}
=
\modulus{\vectorentry{\vect{u}}{1}}^2+
\modulus{\vectorentry{\vect{u}}{2}}^2+
\modulus{\vectorentry{\vect{u}}{3}}^2+
\cdots+
\modulus{\vectorentry{\vect{u}}{m}}^2
</equation>
</p>

<p>Since each modulus is squared, every term is positive, and the sum must also be positive.  (Notice that in general the inner product is a complex number and cannot be compared with zero, but in the special case of $\innerproduct{\vect{u}}{\vect{u}}$ the result is a real number.)</p>

<p>The phrase, <q>with equality if and only if</q> means that we want to show that the statement $\innerproduct{\vect{u}}{\vect{u}}= 0$ (<ie /> with equality) is equivalent (<q>if and only if</q>) to the statement $\vect{u}=\zerovector$.</p>

<p>If $\vect{u}=\zerovector$, then it is a straightforward computation to see that $\innerproduct{\vect{u}}{\vect{u}}= 0$.  In the other direction, assume that $\innerproduct{\vect{u}}{\vect{u}}= 0$.  As before, $\innerproduct{\vect{u}}{\vect{u}}$ is a sum of moduli.  So we have
<equation>
0=\innerproduct{\vect{u}}{\vect{u}}=
\modulus{\vectorentry{\vect{u}}{1}}^2+
\modulus{\vectorentry{\vect{u}}{2}}^2+
\modulus{\vectorentry{\vect{u}}{3}}^2+
\cdots+
\modulus{\vectorentry{\vect{u}}{m}}^2
</equation></p>

<p>Now we have a sum of squares equaling zero, so each term must be zero.  Then by similar logic,
$\modulus{\vectorentry{\vect{u}}{i}}=0$
will imply that
$\vectorentry{\vect{u}}{i}=0$,
since $0+0i$ is the only complex number with zero modulus.  Thus every entry of $\vect{u}$ is zero and so $\vect{u}=\zerovector$, as desired.</p>

</proof>
</theorem>

<p>Notice that <acroref type="theorem" acro="PIP" /> contains <em>three</em> implications:
<alignmath>
<![CDATA[\vect{u}\in\complex{m}&\Rightarrow\innerproduct{\vect{u}}{\vect{u}}\geq 0\\]]>
<![CDATA[\vect{u}=\zerovector&\Rightarrow\innerproduct{\vect{u}}{\vect{u}}=0\\]]>
<![CDATA[\innerproduct{\vect{u}}{\vect{u}}=0&\Rightarrow\vect{u}=\zerovector]]>
</alignmath></p>

<p>The results contained in <acroref type="theorem" acro="PIP" /> are summarized by saying <q>the inner product is <define>positive definite</define>.</q></p>

<sageadvice acro="EVIC" index="exact vs.\ inexact computations">
<title>Exact Versus Inexact Computations</title>

<p>We are now at a crossroads in our use of Sage.  So far our computations have involved rational numbers: fractions of two integers.  Sage is able to work with integers of seemingly unlimited size, and then can work with rational numbers exactly.  So all of our computations have been exactly correct so far.  In practice, many computations, especially those that originate with data, are not so precise.  Then we <em>represent</em> real numbers by <q>floating point numbers.</q>  Since the real numbers are infinite, finite computers must fake it with an extremely large, but still finite, collection of numbers.  The price we pay is that some computations will be just slightly imprecise when there is no number available that represents the exact answer.</p>

<p>You should now appreciate two problems that occur.  If we were to row-reduce a matrix with floating point numbers, there are potentially many computations and if a small amount of imprecision arises in each one, these errors can accumulate and lead to wildly incorrect answers.  When we row-reduce a matrix, whether or not an entry is zero or not is critically important in the decisions we make about which row operation to perform.  If we have an extremely small number (like $10^{-16}$) how can we be sure if it is zero or not?</p>

<p>Why discuss this now?  What is $\alpha=\sqrt{\frac{7}{3}}$?  Hard to say exactly, but it is definitely not a rational number.  Norms of vectors will feature prominently in all our discussions about orthogonal vectors, so we now have to recognize the need to work with square roots properly.  We have two strategies in Sage.</p>

<p>The number system <code>QQbar</code>, also known as the <q>field of algebraic numbers,</q> is a truly amazing feature of Sage.  It contains the rational numbers, plus <em>every</em> root of <em>every</em> polynomial with coefficients that are rational numbers.  For example, notice that $\alpha$ above is one solution to the polynomial equation $3x^2-7=0$ and thus is a number in <code>QQbar</code>, so Sage can work with it <em>exactly</em>.  These numbers are called <q>algebraic numbers</q> and you can recognize them since they print with a question mark near the end to remind you that when printed as a decimal they are approximations of numbers that Sage carries internally as exact quantities.  For example $\alpha$ can be created with <code>QQbar(sqrt(7/3))</code> and will print as <code>1.527525231651947</code>?.  Notice that complex numbers begin with the introduction of the imaginary number $i$, which is a root of the polynomial equation $x^2+1=0$, so the field of algebraic numbers contains many complex numbers.  The downside of <code>QQbar</code> is that computations are slow (relatively speaking), so this number system is most useful for examples and demonstrations.</p>

<p>The other strategy is to work strictly with approximate numbers, cognizant of the potential for inaccuracies.  Sage has two such number systems: <code>RDF</code> and <code>CDF</code>, which are comprised of <q>double precision</q> floating point numbers, first limited to just the reals, then expanded to the complexes.  Double-precision refers to the use of 64 bits to store the sign, mantissa and exponent in the representation of a real number.  This gives 53 bits of precision.  Do not confuse these fields with <code>RR</code> and <code>CC</code>, which are similar in appearance but very different in implementation.  Sage has implementations of several computations designed exclusively for <code>RDF</code> and <code>CDF</code>, such as the norm.  And they are very, very fast.  But some computations, like echelon form, can be wildly unreliable with these approximate numbers.  We will have more to say about this as we go.  In practice, you can use <code>CDF</code>, since <code>RDF</code> is a subset and only different in very limited cases.</p>

<p>In summary, <code>QQbar</code> is an extension of <code>QQ</code> which allows exact computations, but can be slow for large examples.  <code>RDF</code> and <code>CDF</code> are fast, with special algorithms to control much of the imprecision in some, but not all, computations.  So we need to be vigilant and skeptical when we work with these approximate numbers.  We will use both strategies, as appropriate.</p>

</sageadvice>

<sageadvice acro="CNIP" index="conjugates, norms, inner products">
<title>Conjugates, Norms and Inner Products</title>

<p>Conjugates, of complex numbers and of vectors, are straightforward, in <code>QQbar</code> or in <code>CDF</code>.</p>

<sage>
<input>alpha = QQbar(2 + 3*I)
alpha.conjugate()
</input>
<output>2 - 3*I
</output>
</sage>

<sage>
<input>beta = CDF(2+3*I)
beta.conjugate()
</input>
<output>2.0 - 3.0*I
</output>
</sage>

<sage>
<input>v = vector(QQbar, [5-3*I, 2+6*I])
v.conjugate()
</input>
<output>(5 + 3*I, 2 - 6*I)
</output>
</sage>

<sage>
<input>w = vector(CDF, [5-3*I, 2+6*I])
w.conjugate()
</input>
<output>(5.0 + 3.0*I, 2.0 - 6.0*I)
</output>
</sage>

<p>The term <q>inner product</q> means slightly different things to different people.  For some, it is the <q>dot product</q> that you may have seen in a calculus or physics course.  Our inner product could be called the <q>Hermitian inner product</q> to emphasize the use of vectors over the complex numbers and conjugating some of the entries.  So Sage has a <code>.dot_product()</code>, <code>.inner_product()</code>, and <code>.hermitian_inner_product()</code> <mdash /> we want to use the last one.</p>

<p>From now on, when we mention an inner product in the context of using Sage, we will mean <code>.hermitian_inner_product()</code>.  We will redo the first part of <acroref type="example" acro="CSIP" />.  Notice that the syntax is a bit asymmetric.</p>

<sage>
<input>u = vector(QQbar, [2+3*I,  5+2*I, -3+I])
v = vector(QQbar, [1+2*I, -4+5*I,  5*I])
u.hermitian_inner_product(v)
</input>
<output>3 + 19*I
</output>
</sage>

<p>Norms are as easy as conjugates.  Easier maybe.  It might be useful to realize that Sage uses entirely distinct code to compute an exact norm over <code>QQbar</code> versus an approximate norm over <code>CDF</code>, though that is totally transparent as you issue commands.  Here is <acroref type="example" acro="CNSV" /> reprised.</p>

<sage>
<input>entries = [3+2*I, 1-6*I, 2+4*I, 2+I]
u = vector(QQbar, entries)
u.norm()
</input>
<output>8.66025403784439?
</output>
</sage>

<sage>
<input>u = vector(CDF, entries)
u.norm()
</input>
<output>8.66025403784
</output>
</sage>

<sage>
<input>numerical_approx(5*sqrt(3), digits = 30)
</input>
<output>8.66025403784438646763723170753
</output>
</sage>

<p>We have three different numerical approximations, the latter 30-digit number being an approximation to the answer in the text.  But there is no inconsistency between them.  The first, an algebraic number, is represented internally as $5*a$ where $a$ is a root of the polynomial equation $x^2-3=0$, in other words it is $5\sqrt{3}$.  The <code>CDF</code> value prints with a few digits less than what is carried internally.  Notice that our different definitions of the inner product make no difference in the computation of a norm.</p>

<p>One warning now that we are working with complex numbers.  It is easy to <q>clobber</q> the symbol <code>I</code> used for the imaginary number $i$.  In other words, Sage will allow you to assign it to something else, rendering it useless.  An identity matrix is a likely reassignment.  If you run the next compute cell, be sure to evaluate the compute cell afterward to restore <code>I</code> to its usual role.</p>

<sage>
<input>alpha = QQbar(5 - 6*I)
I = identity_matrix(2)
beta = QQbar(2+5*I)
</input>
<output>Traceback (most recent call last):
...
TypeError: Illegal initializer for algebraic number
</output>
</sage>

<sage>
<input>restore()
I^2
</input>
<output>-1
</output>
</sage>

<p>We will finish with a verification of <acroref type="theorem" acro="IPN" />.  To test equality it is best if we work with entries from <code>QQbar</code>.</p>

<sage>
<input>v = vector(QQbar, [2-3*I, 9+5*I, 6+2*I, 4-7*I])
v.hermitian_inner_product(v) == v.norm()^2
</input>
<output>True
</output>
</sage>

</sageadvice>

</subsection>

<subsection acro="OV">
<title>Orthogonal Vectors</title>

<p><q>Orthogonal</q> is a generalization of <q>perpendicular.</q>  You may have used mutually perpendicular vectors in a physics class, or you may recall from a calculus class that perpendicular vectors have a zero dot product.  We will now extend these ideas into the realm of higher dimensions and complex scalars.</p>

<definition acro="OV" index="orthogonal!vector pairs">
<title>Orthogonal Vectors</title>
<p>A pair of vectors, $\vect{u}$ and $\vect{v}$, from $\complex{m}$ are <define>orthogonal</define> if their inner product is zero, that is, $\innerproduct{\vect{u}}{\vect{v}}=0$.</p>

</definition>

<example acro="TOV" index="orthogonal vectors">
<title>Two orthogonal vectors</title>

<p>The vectors
<alignmath>
<![CDATA[\vect{u}&=\colvector{2 + 3i\\4 - 2i\\1 + i\\1 + i}]]>
<![CDATA[&]]>
<![CDATA[\vect{v}&=\colvector{1 - i\\2 + 3i\\4 - 6i\\1}]]>
</alignmath>
are orthogonal since
<alignmath>
\innerproduct{\vect{u}}{\vect{v}}
<![CDATA[&=(2-3i)(1-i)+(4+2i)(2+3i)+(1-i)(4-6i)+(1-i)(1)\\]]>
<![CDATA[&=(-1-5i)+(2+16i)+(-2-10i)+(1-i)\\]]>
<![CDATA[&=0+0i.]]>
</alignmath></p>

</example>

<p>We extend this definition to whole sets by requiring vectors to be pairwise orthogonal.  Despite using the same word, careful thought about what objects you are using will eliminate any source of confusion.</p>

<definition acro="OSV" index="orthogonal!set of vectors">
<title>Orthogonal Set of Vectors</title>
<p>Suppose that $S=\set{\vectorlist{u}{n}}$ is a set of vectors from $\complex{m}$.  Then $S$ is an <define>orthogonal set</define> if every pair of different vectors from $S$ is orthogonal, that is $\innerproduct{\vect{u}_i}{\vect{u}_j}=0$ whenever $i\neq j$.</p>

</definition>

<!-- TODO: Need a good example right here -->
<p>We now define the prototypical orthogonal set, which we will reference repeatedly.</p>

<definition acro="SUV" index="unit vectors">
<title>Standard Unit Vectors</title>
<p>Let $\vect{e}_j\in\complex{m}$, $1\leq j\leq m$ denote the column vectors defined by
<alignmath>
\vectorentry{\vect{e}_j}{i}
<![CDATA[&=]]>
\begin{cases}
<![CDATA[0&\text{if $i\neq j$}\\]]>
<![CDATA[1&\text{if $i=j$}]]>
\end{cases}
</alignmath>
</p>

<p>Then the set
<alignmath>
<![CDATA[\set{\vectorlist{e}{m}}&=\setparts{\vect{e}_j}{1\leq j\leq m}]]>
</alignmath>
is the set of <define>standard unit vectors</define> in $\complex{m}$.</p>

<notation acro="SUV" index="standard unit vector">
<title>Standard Unit Vectors</title>
<usage>$\vect{e}_i$</usage>
</notation>
</definition>

<p>Notice that $\vect{e}_j$ is identical to column $j$ of the $m\times m$ identity matrix $I_m$ (<acroref type="definition" acro="IM" />) and is a pivot column for $I_m$, since the identity matrix is in reduced row-echelon form.  These observations will often be useful.  We will reserve the notation $\vect{e}_i$ for these vectors.  It is not hard to see that the set of standard unit vectors is an orthogonal set.</p>

<example acro="SUVOS" index="unit vectors!orthogonal">
<title>Standard Unit Vectors are an Orthogonal Set</title>

<p>Compute the inner product of two distinct vectors from the set of standard unit vectors (<acroref type="definition" acro="SUV" />), say $\vect{e}_i$, $\vect{e}_j$, where $i\neq j$,
<alignmath>
<![CDATA[\innerproduct{\vect{e}_i}{\vect{e}_j}&=]]>
\conjugate{0}0+
\conjugate{0}0+\cdots+
\conjugate{1}0+\cdots+
\conjugate{0}0+\cdots+
\conjugate{0}1+\cdots+
\conjugate{0}0+
\conjugate{0}0\\
<![CDATA[&=0(0)+0(0)+\cdots+1(0)+\cdots+0(1)+\cdots+0(0)+0(0)\\]]>
<![CDATA[&=0]]>
</alignmath></p>

<p>So the set $\set{\vectorlist{e}{m}}$ is an orthogonal set.</p>

</example>

<!--  Next example output (rescaled) from: -->
<!--  GramSchmidt[{{1+I,1, 1-I,I},{I,1+I,-1, -I}, {I,-I, -1+I,1}, {-1-I,I,1,-1}}, -->
<!--  InnerProduct(arrow)(Conjugate[#1].#2&)]//Simplify -->
<example acro="AOS" index="orthogonal!set">
<title>An orthogonal set</title>

<p>The set
<equation>
\set{\vect{x}_1,\,\vect{x}_2,\,\vect{x}_3,\,\vect{x}_4}=
\set{
\colvector{1+i\\1\\1-i\\i},\,
\colvector{1+5i\\6+5i\\-7-i\\1-6i},\,
\colvector{-7+34i\\-8-23i\\-10+22i\\30+13i},\,
\colvector{-2-4i\\6+i\\4+3i\\6-i}
}
</equation>
is an orthogonal set.</p>

<p>Since the inner product is anti-commutative (<acroref type="theorem" acro="IPAC" />) we can test pairs of different vectors in any order.  If the result is zero, then it will also be zero if the inner product is computed in the opposite order.  This means there are six different pairs of vectors to use in an inner product computation.  We will do two and you can practice your inner products on the other four.
<alignmath>
<![CDATA[\innerproduct{\vect{x}_1}{\vect{x}_3}&=]]>
(1-i)(-7+34i)+(1)(-8-23i)+(1+i)(-10+22i)+(-i)(30+13i)\\
<![CDATA[&=(27+41i)+(-8-23i)+(-32+12i)+(13-30i)\\]]>
<![CDATA[&=0+0i]]>
<intertext>and</intertext>
<![CDATA[\innerproduct{\vect{x}_2}{\vect{x}_4}&=]]>
(1-5i)(-2-4i)+(6-5i)(6+i)+(-7+i)(4+3i)+(1+6i)(6-i)\\
<![CDATA[&=(-22+6i)+(41-24i)+(-31-17i)+(12+35i)\\]]>
<![CDATA[&=0+0i]]>
</alignmath></p>

</example>

<p>So far, this section has seen lots of definitions, and lots of theorems establishing un-surprising consequences of those definitions.  But here is our first theorem that suggests that inner products and orthogonal vectors have some utility.  It is also one of our first illustrations of how to arrive at linear independence as the conclusion of a theorem.</p>

<theorem acro="OSLI" index="orthogonal!linear independence">
<title>Orthogonal Sets are Linearly Independent</title>
<statement>
<indexlocation index="linear independence!orthogonal" />
<p>Suppose that $S$ is an orthogonal set of nonzero vectors.  Then $S$ is linearly independent.</p>

</statement>

<proof>
<p>Let $S=\set{\vectorlist{u}{n}}$ be an orthogonal set of nonzero vectors.  To prove the linear independence of $S$, we can appeal to the definition (<acroref type="definition" acro="LICV" />) and begin with an arbitrary relation of linear dependence (<acroref type="definition" acro="RLDCV" />),
<equation>
\lincombo{\alpha}{u}{n}=\zerovector.
</equation></p>

<p>Then, for every $1\leq i\leq n$, we have
<alignmath>
<![CDATA[&\alpha_i\innerproduct{\vect{u}_i}{\vect{u}_i}\\]]>
<![CDATA[&\quad\quad=\alpha_1(0)+\alpha_2(0)+\cdots+\alpha_i\innerproduct{\vect{u}_i}{\vect{u}_i}+\cdots+\alpha_n(0)]]>
<![CDATA[&&]]><acroref type="property" acro="ZCN" />\\
<![CDATA[&\quad\quad=]]>
\alpha_1\innerproduct{\vect{u}_i}{\vect{u}_1}+
\cdots+
\alpha_i\innerproduct{\vect{u}_i}{\vect{u}_i}+
\cdots+
\alpha_n\innerproduct{\vect{u}_i}{\vect{u}_n}
<![CDATA[&&]]><acroref type="definition" acro="OSV" />\\
<![CDATA[&\quad\quad=]]>
\innerproduct{\vect{u}_i}{\alpha_1\vect{u}_1}+
\innerproduct{\vect{u}_i}{\alpha_2\vect{u}_2}+
\cdots+
\innerproduct{\vect{u}_i}{\alpha_n\vect{u}_n}
<![CDATA[&&]]><acroref type="theorem" acro="IPSM" />\\
<![CDATA[&\quad\quad=]]>
\innerproduct{\vect{u}_i}{\lincombo{\alpha}{u}{n}}
<![CDATA[&&]]><acroref type="theorem" acro="IPVA" />\\
<![CDATA[&\quad\quad=]]>
\innerproduct{\vect{u}_i}{\zerovector}
<![CDATA[&&]]><acroref type="definition" acro="RLDCV" />\\
<![CDATA[&\quad\quad=0]]>
<![CDATA[&&]]><acroref type="definition" acro="IP" />
</alignmath></p>

<p>Because $\vect{u}_i$ was assumed to be nonzero, <acroref type="theorem" acro="PIP" /> says $\innerproduct{\vect{u}_i}{\vect{u}_i}$ is nonzero and thus $\alpha_i$ must be zero.  So we conclude that $\alpha_i=0$ for all $1\leq i\leq n$ in any relation of linear dependence on $S$.  But this says that $S$ is a linearly independent set since the only way to form a relation of linear dependence is the trivial way (<acroref type="definition" acro="LICV" />).  Boom!</p>

</proof>
</theorem>

</subsection>

<subsection acro="GSP">
<title>Gram-Schmidt Procedure</title>

<p>The Gram-Schmidt Procedure is really a theorem.  It says that if we begin with a linearly independent set of $p$ vectors, $S$, then we can do a number of calculations with these vectors and produce an orthogonal set of $p$ vectors, $T$, so that $\spn{S}=\spn{T}$.  Given the large number of computations involved, it is indeed a procedure to do all the necessary computations, and it is best employed on a computer.  However, it also has value in proofs where we may on occasion wish to replace a linearly independent set by an orthogonal set.</p>

<p>This is our first occasion to use the technique of <q>mathematical induction</q> for a proof, a technique we will see again several times, especially in <acroref type="chapter" acro="D" />.  So study the simple example described in <acroref type="technique" acro="I" /> first.</p>

<theorem acro="GSP" index="Gram-Schmidt!column vectors">
<title>Gram-Schmidt Procedure</title>
<statement>
<p>Suppose that $S=\set{\vectorlist{v}{p}}$ is a linearly independent set of vectors in $\complex{m}$.  Define the vectors $\vect{u}_i$, $1\leq i\leq p$ by
<equation>
\vect{u}_i=\vect{v}_i
-\frac{\innerproduct{\vect{u}_1}{\vect{v}_i}}{\innerproduct{\vect{u}_1}{\vect{u}_1}}\vect{u}_1
-\frac{\innerproduct{\vect{u}_2}{\vect{v}_i}}{\innerproduct{\vect{u}_2}{\vect{u}_2}}\vect{u}_2
-\frac{\innerproduct{\vect{u}_3}{\vect{v}_i}}{\innerproduct{\vect{u}_3}{\vect{u}_3}}\vect{u}_3
-\cdots
-\frac{\innerproduct{\vect{u}_{i-1}}{\vect{v}_i}}{\innerproduct{\vect{u}_{i-1}}{\vect{u}_{i-1}}}\vect{u}_{i-1}
</equation></p>

<p>Let $T=\set{\vectorlist{u}{p}}$.  Then $T$ is an orthogonal set of nonzero vectors, and $\spn{T}=\spn{S}$.</p>

</statement>

<proof>
<p>We will prove the result by using induction on $p$ (<acroref type="technique" acro="I" />).  To begin, we prove that $T$ has the desired properties when $p=1$.  In this case $\vect{u}_1=\vect{v}_1$ and $T=\set{\vect{u}_1}=\set{\vect{v}_1}=S$.  Because $S$ and $T$ are equal, $\spn{S}=\spn{T}$.  Equally trivial, $T$ is an orthogonal set.  If $\vect{u}_1=\zerovector$, then $S$ would be a linearly dependent set, a contradiction.</p>

<p>Suppose that the theorem is true for any set of $p-1$ linearly independent vectors.  Let $S=\set{\vectorlist{v}{p}}$ be a linearly independent set of $p$ vectors.  Then $S^\prime=\set{\vectorlist{v}{p-1}}$ is also linearly independent.  So we can apply the theorem to $S^\prime$ and construct the vectors $T^\prime=\set{\vectorlist{u}{p-1}}$.  $T^\prime$ is therefore an orthogonal set of nonzero vectors and $\spn{S^\prime}=\spn{T^\prime}$.  Define
<equation>
\vect{u}_p=\vect{v}_p
-\frac{\innerproduct{\vect{u}_1}{\vect{v}_p}}{\innerproduct{\vect{u}_1}{\vect{u}_1}}\vect{u}_1
-\frac{\innerproduct{\vect{u}_2}{\vect{v}_p}}{\innerproduct{\vect{u}_2}{\vect{u}_2}}\vect{u}_2
-\frac{\innerproduct{\vect{u}_3}{\vect{v}_p}}{\innerproduct{\vect{u}_3}{\vect{u}_3}}\vect{u}_3
-\cdots
-\frac{\innerproduct{\vect{u}_{p-1}}{\vect{v}_p}}{\innerproduct{\vect{u}_{p-1}}{\vect{u}_{p-1}}}\vect{u}_{p-1}
</equation>
and let $T=T^\prime\cup\set{\vect{u}_p}$.  We need to now show that $T$ has several properties by building on what we know about $T^\prime$.  But first notice that the above equation has no problems with the denominators ($\innerproduct{\vect{u}_i}{\vect{u}_i}$) being zero, since the $\vect{u}_i$ are from $T^\prime$, which is composed of nonzero vectors.</p>

<p>We show that $\spn{T}=\spn{S}$, by first establishing that $\spn{T}\subseteq\spn{S}$.  Suppose $\vect{x}\in\spn{T}$, so
<equation>
\vect{x}=\lincombo{a}{u}{p}
</equation>
The term $a_p\vect{u}_p$ is a linear combination of vectors from $T^\prime$ and the vector $\vect{v}_p$, while the remaining terms are a linear combination of vectors from $T^\prime$.  Since $\spn{T^\prime}=\spn{S^\prime}$, any term that is a multiple of a vector from $T^\prime$ can be rewritten as a linear combination of vectors from $S^\prime$.  The remaining term $a_p\vect{v}_p$ is a multiple of a vector in $S$.  So we see that $\vect{x}$ can be rewritten as a linear combination of vectors from $S$, <ie /> $\vect{x}\in\spn{S}$.</p>

<p>To show that $\spn{S}\subseteq\spn{T}$, begin with $\vect{y}\in\spn{S}$, so
<equation>
\vect{y}=\lincombo{a}{v}{p}
</equation>
</p>

<p>Rearrange our defining equation for $\vect{u}_p$ by solving for $\vect{v}_p$.  Then the term $a_p\vect{v}_p$ is a multiple of a linear combination of elements of $T$.  The remaining terms are a linear combination of $\vectorlist{v}{p-1}$, hence an element of $\spn{S^\prime}=\spn{T^\prime}$.  Thus these remaining terms can be written as a linear combination of the vectors in $T^\prime$.   So $\vect{y}$ is a linear combination of vectors from $T$, <ie /> $\vect{y}\in\spn{T}$.</p>

<p>The elements of $T^\prime$ are nonzero, but what about $\vect{u}_p$?  Suppose to the contrary that $\vect{u}_p=\zerovector$,
<alignmath>
<![CDATA[\zerovector&=\vect{u}_p=\vect{v}_p]]>
-\frac{\innerproduct{\vect{u}_1}{\vect{v}_p}}{\innerproduct{\vect{u}_1}{\vect{u}_1}}\vect{u}_1
-\frac{\innerproduct{\vect{u}_2}{\vect{v}_p}}{\innerproduct{\vect{u}_2}{\vect{u}_2}}\vect{u}_2
-\frac{\innerproduct{\vect{u}_3}{\vect{v}_p}}{\innerproduct{\vect{u}_3}{\vect{u}_3}}\vect{u}_3
-\cdots
-\frac{\innerproduct{\vect{u}_{p-1}}{\vect{v}_p}}{\innerproduct{\vect{u}_{p-1}}{\vect{u}_{p-1}}}\vect{u}_{p-1}\\
<![CDATA[&\vect{v}_p=]]>
 \frac{\innerproduct{\vect{u}_1}{\vect{v}_p}}{\innerproduct{\vect{u}_1}{\vect{u}_1}}\vect{u}_1
+\frac{\innerproduct{\vect{u}_2}{\vect{v}_p}}{\innerproduct{\vect{u}_2}{\vect{u}_2}}\vect{u}_2
+\frac{\innerproduct{\vect{u}_3}{\vect{v}_p}}{\innerproduct{\vect{u}_3}{\vect{u}_3}}\vect{u}_3
+\cdots
+\frac{\innerproduct{\vect{u}_{p-1}}{\vect{v}_p}}{\innerproduct{\vect{u}_{p-1}}{\vect{u}_{p-1}}}\vect{u}_{p-1}
</alignmath></p>

<p>Since $\spn{S^\prime}=\spn{T^\prime}$ we can write the vectors $\vectorlist{u}{p-1}$ on the right side of this equation in terms of the vectors $\vectorlist{v}{p-1}$ and we then have the vector $\vect{v}_p$ expressed as a linear combination of the other $p-1$ vectors in $S$, implying that $S$ is a linearly dependent set (<acroref type="theorem" acro="DLDS" />), contrary to our lone hypothesis about $S$.</p>

<p>Finally, it is a simple matter to establish that $T$ is an orthogonal set, though it will not appear so simple looking.  Think about your objects as you work through the following <mdash /> what is a vector and what is a scalar.  Since $T^\prime$ is an orthogonal set by induction, most pairs of elements in $T$ are already known to be orthogonal.  We just need to test <q>new</q> inner products, between $\vect{u}_p$ and $\vect{u}_i$, for $1\leq i\leq p-1$.  Here we go, using summation notation,
<alignmath>
<![CDATA[\innerproduct{\vect{u}_i}{\vect{u}_p}&=]]>
\innerproduct{\vect{u}_i}{
\vect{v}_p-\sum_{k=1}^{p-1}\frac{\innerproduct{\vect{u}_k}{\vect{v}_p}}{\innerproduct{\vect{u}_k}{\vect{u}_k}}\vect{u}_k
}
\\
<![CDATA[&=]]>
\innerproduct{\vect{u}_i}{\vect{v}_p}
-
\innerproduct{\vect{u}_i}{
\sum_{k=1}^{p-1}\frac{\innerproduct{\vect{u}_k}{\vect{v}_p}}{\innerproduct{\vect{u}_k}{\vect{u}_k}}\vect{u}_k
}
<![CDATA[&&]]><acroref type="theorem" acro="IPVA" />\\
<![CDATA[&=]]>
\innerproduct{\vect{u}_i}{\vect{v}_p}
-
\sum_{k=1}^{p-1}\innerproduct{\vect{u}_i}{
\frac{\innerproduct{\vect{u}_k}{\vect{v}_p}}{\innerproduct{\vect{u}_k}{\vect{u}_k}}\vect{u}_k
}
<![CDATA[&&]]><acroref type="theorem" acro="IPVA" />\\
<![CDATA[&=]]>
\innerproduct{\vect{u}_i}{\vect{v}_p}
-
\sum_{k=1}^{p-1}\frac{\innerproduct{\vect{u}_k}{\vect{v}_p}}{\innerproduct{\vect{u}_k}{\vect{u}_k}}\innerproduct{\vect{u}_i}{\vect{u}_k}
<![CDATA[&&]]><acroref type="theorem" acro="IPSM" />\\
<![CDATA[&=]]>
\innerproduct{\vect{u}_i}{\vect{v}_p}
-
\frac{\innerproduct{\vect{u}_i}{\vect{v}_p}}{\innerproduct{\vect{u}_i}{\vect{u}_i}}\innerproduct{\vect{u}_i}{\vect{u}_i}
-
\sum_{k\neq i}\frac{\innerproduct{\vect{u}_k}{\vect{v}_p}}{\innerproduct{\vect{u}_k}{\vect{u}_k}}(0)
<![CDATA[&&\text{Induction Hypothesis}\\]]>
<![CDATA[&=]]>
\innerproduct{\vect{u}_i}{\vect{v}_p}
-
\innerproduct{\vect{u}_i}{\vect{v}_p}
-
\sum_{k\neq i}0\\
<![CDATA[&=0]]>
</alignmath>
</p>

</proof>
</theorem>

<example acro="GSTV" index="Gram-Schmidt!three vectors">
<title>Gram-Schmidt of three vectors</title>

<p>We will illustrate the Gram-Schmidt process with three vectors.  Begin with the linearly independent (check this!) set
<equation>
S=\set{\vect{v}_1,\,\vect{v}_2,\,\vect{v}_3}=\set{
\colvector{1\\1+i\\1},\,
\colvector{-i\\1\\1+i},\,
\colvector{0\\i\\i}
}
</equation></p>

<p>Then
<alignmath>
<![CDATA[\vect{u}_1&=\vect{v_1}=\colvector{1\\1+i\\1}\\]]>
<![CDATA[\vect{u}_2&=\vect{v}_2]]>
-\frac{\innerproduct{\vect{u}_1}{\vect{v}_2}}{\innerproduct{\vect{u}_1}{\vect{u}_1}}\vect{u}_1
=\frac{1}{4}\colvector{-2-3i\\1-i\\2+5i}\\
<![CDATA[\vect{u}_3&=\vect{v}_3]]>
-\frac{\innerproduct{\vect{u}_1}{\vect{v}_3}}{\innerproduct{\vect{u}_1}{\vect{u}_1}}\vect{u}_1
-\frac{\innerproduct{\vect{u}_2}{\vect{v}_3}}{\innerproduct{\vect{u}_2}{\vect{u}_2}}\vect{u}_2
=\frac{1}{11}\colvector{-3-i\\1+3i\\-1-i}
</alignmath>
and
<equation>
T=\set{\vect{u}_1,\,\vect{u}_2,\,\vect{u}_3}
=\set{
\colvector{1\\1+i\\1},\,
\frac{1}{4}\colvector{-2-3i\\1-i\\2+5i},\,
\frac{1}{11}\colvector{-3-i\\1+3i\\-1-i}
}
</equation>
is an orthogonal set (which you can check) of nonzero vectors and $\spn{T}=\spn{S}$ (all by <acroref type="theorem" acro="GSP" />).  Of course, as a by-product of orthogonality, the set $T$ is also linearly independent (<acroref type="theorem" acro="OSLI" />).</p>

</example>

<p>One final definition related to orthogonal vectors.</p>

<definition acro="ONS" index="orthonormal">
<title>OrthoNormal Set</title>
<p>Suppose $S=\set{\vectorlist{u}{n}}$ is an orthogonal set of vectors such that $\norm{\vect{u}_i}=1$ for all $1\leq i\leq n$.  Then $S$ is an <define>orthonormal</define> set of vectors.</p>

</definition>

<p>Once you have an orthogonal set, it is easy to convert it to an orthonormal set <mdash /> multiply each vector by the reciprocal of its norm, and the resulting vector will have norm 1.  This scaling of each vector will not affect the orthogonality properties (apply <acroref type="theorem" acro="IPSM" />).</p>

<example acro="ONTV" index="orthonormal set!three vectors">
<title>Orthonormal set, three vectors</title>

<p>The set
<equation>
T=\set{\vect{u}_1,\,\vect{u}_2,\,\vect{u}_3}
=\set{
\colvector{1\\1+i\\1},\,
\frac{1}{4}\colvector{-2-3i\\1-i\\2+5i},\,
\frac{1}{11}\colvector{-3-i\\1+3i\\-1-i}
}
</equation>
from <acroref type="example" acro="GSTV" /> is an orthogonal set.</p>

<p>We compute the norm of each vector,
<alignmath>
<![CDATA[\norm{\vect{u}_1}=2&&]]>
<![CDATA[\norm{\vect{u}_2}=\frac{1}{2}\sqrt{11}&&]]>
\norm{\vect{u}_3}=\frac{\sqrt{2}}{\sqrt{11}}
</alignmath>
</p>

<p>Converting each vector to a norm of 1, yields an orthonormal set,
<alignmath>
<![CDATA[\vect{w}_1&=\frac{1}{2}\colvector{1\\1+i\\1}\\]]>
<![CDATA[\vect{w}_2&=\frac{1}{\frac{1}{2}\sqrt{11}}\frac{1}{4}\colvector{-2-3i\\1-i\\2+5i}=\frac{1}{2\sqrt{11}}\colvector{-2-3i\\1-i\\2+5i}\\]]>
<![CDATA[\vect{w}_3&=\frac{1}{\frac{\sqrt{2}}{\sqrt{11}}}\frac{1}{11}\colvector{-3-i\\1+3i\\-1-i}=\frac{1}{\sqrt{22}}\colvector{-3-i\\1+3i\\-1-i}]]>
</alignmath>
</p>

</example>

<example acro="ONFV" index="orthonormal set!four vectors">
<title>Orthonormal set, four vectors</title>

<p>As an exercise convert the linearly independent set
<equation>
S=\set{
\colvector{1+i\\1\\1-i\\i},\,
\colvector{i\\1+i\\-1\\-i},\,
\colvector{i\\-i\\ -1+i\\1},\,
\colvector{-1-i\\i\\1\\-1}
}
</equation>
to an orthogonal set via the Gram-Schmidt Process (<acroref type="theorem" acro="GSP" />) and then scale the vectors to norm 1 to create an orthonormal set.  You should get the same set you would if you scaled the orthogonal set of <acroref type="example" acro="AOS" /> to become an orthonormal set.</p>

</example>

<p>We will see orthonormal sets again in <acroref type="subsection" acro="MINM.UM" />.   They are intimately related to unitary matrices (<acroref type="definition" acro="UM" />) through <acroref type="theorem" acro="CUMOS" />.  Some of the utility of orthonormal sets is captured by <acroref type="theorem" acro="COB" /> in <acroref type="subsection" acro="B.OBC" />.   Orthonormal sets appear once again in <acroref type="section" acro="OD" /> where they are key in orthonormal diagonalization.</p>

<sageadvice acro="OGS" index="orthogonality and Gram-Schmidt">
<title>Orthogonality and Gram-Schmidt</title>
<p>It is easy enough to check a pair of vectors for orthogonality (is the inner product zero?).  To check that a set is orthogonal, we just need to do this repeatedly. This is a redo of <acroref type="example" acro="AOS" />.</p>

<sage>
<input>x1 = vector(QQbar, [    1+I,       1,      1-I,       I])
x2 = vector(QQbar, [  1+5*I,   6+5*I,     -7-I,   1-6*I])
x3 = vector(QQbar, [-7+34*I, -8-23*I, -10+22*I, 30+13*I])
x4 = vector(QQbar, [ -2-4*I,     6+I,    4+3*I,     6-I])
S = [x1, x2, x3, x4]
ips = [S[i].hermitian_inner_product(S[j])
                  for i in range(3) for j in range(i+1,3)]
all([ip == 0 for ip in ips])
</input>
<output>True
</output>
</sage>

<p>Notice how the list comprehension computes each pair just once, and never checks the inner product of a vector with itself.  If we wanted to check that a set is orthonormal, the <q>normal</q> part is less involved.  We will check the set above, even though we can clearly see that the four vectors are not even close to being unit vectors.  Be sure to run the above definitions of <code>S</code> before running the next compute cell.</p>

<sage>
<input>ips = [S[i].hermitian_inner_product(S[i]) for i in range(3)]
all([ip == 1 for ip in ips])
</input>
<output>False
</output>
</sage>

<p>Applying the Gram-Schmidt procedure to a set of vectors is the type of computation that a program like Sage is perfect for.  Gram-Schmidt is implemented as a method for matrices, where we interpret the rows of the matrix as the vectors in the original set.  The result is two matrices, where the first has rows that are the orthogonal vectors.  The second matrix has rows that provide linear combinations of the orthogonal vectors that equal the original vectors.  The original vectors do not need to form a linearly independent set, and when the set is linearly dependent, then zero vectors produced are not part of the returned set.</p>

<p>Over <code>CDF</code> the set is automatically orthonormal, and since a different algorithm is used (to help control the imprecisions), the results will look different than what would result from <acroref type="theorem" acro="GSP" />.  We will illustrate with the vectors from <acroref type="example" acro="GSTV" />.</p>

<sage>
<input>v1 = vector(CDF, [ 1, 1+I,   1])
v2 = vector(CDF, [-I,   1, 1+I])
v3 = vector(CDF, [ 0,   I,   I])
A = matrix([v1,v2,v3])
G, M = A.gram_schmidt()
G.round(5)
</input>
<output>[                -0.5         -0.5 - 0.5*I                 -0.5]
[ 0.30151 + 0.45227*I -0.15076 + 0.15076*I -0.30151 - 0.75378*I]
[   0.6396 + 0.2132*I   -0.2132 - 0.6396*I    0.2132 + 0.2132*I]
</output>
</sage>

<p>We formed the matrix A with the three vectors as rows, and of the two outputs we are interested in the first one, whose rows form the orthonormal set.  We round the numbers to 5 digits, just to make the result fit nicely on your screen.  Let us do it again, now exactly over <code>QQbar</code>.  We will output the entries of the matrix as list, working across rows first, so it fits nicely.</p>

<sage>
<input>v1 = vector(QQbar, [ 1, 1+I,   1])
v2 = vector(QQbar, [-I,   1, 1+I])
v3 = vector(QQbar, [ 0,   I,   I])
A = matrix([v1,v2,v3])
G, M = A.gram_schmidt(orthonormal=True)
Sequence(G.list(), cr=True)
</input>
<output>[
0.50000000000000000?,
0.50000000000000000? + 0.50000000000000000?*I,
0.50000000000000000?,
-0.3015113445777636? - 0.4522670168666454?*I,
0.1507556722888818? - 0.1507556722888818?*I,
0.3015113445777636? + 0.7537783614444091?*I,
-0.6396021490668313? - 0.2132007163556105?*I,
0.2132007163556105? + 0.6396021490668313?*I,
-0.2132007163556105? - 0.2132007163556105?*I
]
</output>
</sage>

<p>Notice that we asked for orthonormal output, so the rows of <code>G</code> are the vectors $\set{\vect{w}_1,\,\vect{w}_2,\,\vect{w}_3}$ in <acroref type="example" acro="ONTV" />.  Exactly.  We can restrict ourselves to <code>QQ</code> and forego the <q>normality</q> to obtain just the orthogonal set $\set{\vect{u}_1,\,\vect{u}_2,\,\vect{u}_3}$ of <acroref type="example" acro="GSTV" />.</p>

<sage>
<input>v1 = vector(QQbar, [ 1, 1+I,   1])
v2 = vector(QQbar, [-I,   1, 1+I])
v3 = vector(QQbar, [ 0,   I,   I])
A = matrix([v1, v2, v3])
G, M = A.gram_schmidt(orthonormal=False)
Sequence(G.list(), cr=True)
</input>
<output>[
1,
I + 1,
1,
-0.50000000000000000? - 0.75000000000000000?*I,
0.25000000000000000? - 0.25000000000000000?*I,
0.50000000000000000? + 1.2500000000000000?*I,
-0.2727272727272728? - 0.0909090909090909?*I,
0.0909090909090909? + 0.2727272727272728?*I,
-0.0909090909090909? - 0.0909090909090909?*I
]
</output>
</sage>

<p>Notice that it is an error to ask for an orthonormal set over <code>QQ</code> since you cannot expect to take square roots of rationals and stick with rationals.</p>

<sage>
<input>v1 = vector(QQ, [1, 1])
v2 = vector(QQ, [2, 3])
A = matrix([v1,v2])
G, M = A.gram_schmidt(orthonormal=True)
</input>
<output>Traceback (most recent call last):
...
TypeError: QR decomposition unable to compute square roots in Rational Field
</output>
</sage>

</sageadvice>

</subsection>

<!--   End  o.tex -->
<readingquestions>
<ol>
<li>Is the set
<equation>
\set{\colvector{1\\-1\\2},\,\colvector{5\\3\\-1},\,\colvector{8\\4\\-2}}
</equation>
an orthogonal set?  Why?
</li>
<li>What is the distinction between an orthogonal set and an orthonormal set?
</li>
<li> What is nice about the output of the Gram-Schmidt process?
</li></ol>
</readingquestions>

<exercisesubsection>

<exercise type="C" number="20" rough="4 orthogonalities in Example AOS">
<problem contributor="robertbeezer">Complete <acroref type="example" acro="AOS" /> by verifying that the four remaining inner products are zero.
</problem>
</exercise>

<exercise type="C" number="21" rough="Example GSTV, verify GS output">
<problem contributor="robertbeezer">Verify that the set $T$ created in <acroref type="example" acro="GSTV" /> by the Gram-Schmidt Procedure is an orthogonal set.
</problem>
</exercise>

<exercise type="M" number="60" rough="{u,v,w} on, then u+v, v+w not orthogonal">
<problem contributor="manleyperkel">Suppose that $\set{\vect{u},\,\vect{v},\,\vect{w}}\subseteq\complex{n}$ is an orthonormal set.  Prove that $\vect{u}+\vect{v}$ is not orthogonal to $\vect{v}+\vect{w}$.
</problem>
</exercise>

<exercise type="T" number="10" rough="Prove part 1 Theorem IPVA">
<problem contributor="robertbeezer">Prove part 2 of the conclusion of <acroref type="theorem" acro="IPVA" />.
</problem>
</exercise>

<exercise type="T" number="11" rough="Prove part 1 Theorem IPSM">
<problem contributor="robertbeezer">Prove part 2 of the conclusion of <acroref type="theorem" acro="IPSM" />.
</problem>
</exercise>

<exercise type="T" number="20" rough="Orthogonal to linear combo">
<problem contributor="robertbeezer">Suppose that $\vect{u},\,\vect{v},\,\vect{w}\in\complex{n}$, $\alpha,\,\beta\in\complexes$ and $\vect{u}$ is orthogonal to both $\vect{v}$ and $\vect{w}$.  Prove that $\vect{u}$ is orthogonal to $\alpha\vect{v}+\beta\vect{w}$.
</problem>
<solution contributor="robertbeezer">Vectors are orthogonal if their inner product is zero (<acroref type="definition" acro="OV" />), so we compute,
<alignmath>
\innerproduct{\vect{u}}{\alpha\vect{v}+\beta\vect{w}}
<![CDATA[&=]]>
\innerproduct{\vect{u}}{\alpha\vect{v}}+
\innerproduct{\vect{u}}{\beta\vect{w}}
<![CDATA[&&]]><acroref type="theorem" acro="IPVA" />\\
<![CDATA[&=]]>
\alpha\innerproduct{\vect{u}}{\vect{v}}+
\beta\innerproduct{\vect{u}}{\vect{w}}
<![CDATA[&&]]><acroref type="theorem" acro="IPSM" />\\
<![CDATA[&=]]>
\alpha\left(0\right)+\beta\left(0\right)
<![CDATA[&&]]><acroref type="definition" acro="OV" />\\
<![CDATA[&=0]]>
</alignmath>
So by <acroref type="definition" acro="OV" />, $\vect{u}$ and $\alpha\vect{v}+\beta\vect{w}$ are an orthogonal pair of vectors.
</solution>
</exercise>

<exercise type="T" number="30" rough="Pointless to Gram-Schmidt an orthogonal set">
<problem contributor="stevecanfield">Suppose that the set $S$ in the hypothesis of <acroref type="theorem" acro="GSP" /> is not just linearly independent, but is also orthogonal.  Prove that the set $T$ created by the Gram-Schmidt procedure is equal to $S$.  (Note that we are getting a stronger conclusion than $\spn{T}=\spn{S}$ <mdash /> the conclusion is that $T=S$.)  In other words, it is pointless to apply the Gram-Schmidt procedure to a set that is already orthogonal.
</problem>
</exercise>

<!-- Question suggested by Chili Johnson, Spring 2015 -->
<exercise type="T" number="31" rough="Pointless to Gram-Schmidt twice">
<problem contributor="robertbeezer">Suppose that the set $S$ is linearly independent. Apply the Gram-Schmidt procedure (<acroref type="theorem" acro="GSP" />) twice, creating first the linearly independent set $T_1$ from $S$, and then creating $T_2$ from $T_1$.  As a consequence of <acroref type="exercise" acro="O.T30" />, prove that $T_1=T_2$.  In other words, it is pointless to apply the Gram-Schmidt procedure twice.
</problem>
</exercise>

</exercisesubsection>

</section>
